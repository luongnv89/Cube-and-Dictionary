/**
 * 
 */
package mai.process;

import mai.models.Word;

/**
 * extends a {@link Thread}.
 * a thread to check at a position where the first char of a word is. 
 * It checks all directions (as requirement) with the start point is this position.
 * word is known by its index in the dictionary.
 */
public class MyThread extends Thread {
	/**
	 * index of a word.
	 */
	private int wIndex;
	
	/**
	 * coordinates of the position of the first char of a word on a cube
	 */
	private int x, y, z;


	public MyThread(int index, int x, int y, int z) {
		this.wIndex = index;
		this.x = x;
		this.y = y;
		this.z = z;
	}


	/**
	 * idea is like {@link Sequential#associatedPoint()}.
	 * difference is this method changes the method {@link Word#setFound(boolean)}.
	 */
	@Override
	public void run() {
		int delta = ShareMemory.getListWords().get(wIndex).getWord().length() - 1;
		char[] charsOfWord = ShareMemory.getListWords().get(wIndex).getWord()
				.toCharArray();
		for (int z_lastChar = z - delta; z_lastChar <= z + delta; z_lastChar += delta) {
			if (!ShareMemory.getListWords().get(wIndex).isFound()&&ShareMemory.isAssociatedDic()) {
				for (int y_lastChar = y - delta; y_lastChar <= y + delta; y_lastChar += delta) {
					if (!ShareMemory.getListWords().get(wIndex).isFound()&&ShareMemory.isAssociatedDic()) {
						for (int x_lastChar = x - delta; x_lastChar <= x
								+ delta; x_lastChar += delta) {

							if (!ShareMemory.getListWords().get(wIndex).isFound()&&ShareMemory.isAssociatedDic()
									&& ShareMemory.getCube().inside(x_lastChar, y_lastChar,
											z_lastChar)
									&& !(x == x_lastChar && y == y_lastChar && z == z_lastChar)) {

								int dirX = 0;

								if (x == x_lastChar)
									dirX = 0;
								else
									dirX = (x_lastChar - x)
											/ Math.abs(x_lastChar - x);

								int dirY = 0;

								if (y == y_lastChar)
									dirY = 0;
								else
									dirY = (y_lastChar - y)
											/ Math.abs(y_lastChar - y);

								int dirZ = 0;

								if (z == z_lastChar)
									dirZ = 0;
								else
									dirZ = (z_lastChar - z)
											/ Math.abs(z_lastChar - z);
								
								boolean found = true;
								
								for (int i = 0; i < charsOfWord.length; i++) {
									if (charsOfWord[i] != ShareMemory.getCube().getContent()[x
											+ dirX * i][y + dirY * i][z + dirZ
											* i]) {
										found = false;
										break;
									}
								}
								
								if (found) {
									ShareMemory.getListWords().get(wIndex)
											.setFound(true);
									System.out.println("\nFOUND: "
											+ ShareMemory.getListWords()
													.get(wIndex).getWord());
									break;
								}

							}
						}
					}
				}
			}
		}
	}

	/**
	 * @return {@link #wIndex}
	 */
	public int getWIndex() {
		return wIndex;
	}

}
